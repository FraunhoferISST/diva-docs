(self.webpackChunkdiva_docs=self.webpackChunkdiva_docs||[]).push([[201],{6436:(e,o,a)=>{"use strict";a.r(o),a.d(o,{data:()=>n});const n={key:"v-34bc867c",path:"/development/deployment/docker.html",title:"Docker deployment",lang:"en-US",frontmatter:{},excerpt:"",headers:[{level:2,title:"Environment variables",slug:"environment-variables",children:[]},{level:2,title:"Container and images management",slug:"container-and-images-management",children:[{level:3,title:"Manage microservices",slug:"manage-microservices",children:[]},{level:3,title:"Manage FaaS",slug:"manage-faas",children:[]},{level:3,title:"Manage Airflow",slug:"manage-airflow",children:[]},{level:3,title:"Manage base images",slug:"manage-base-images",children:[]}]}],filePathRelative:"development/deployment/docker.md",git:{contributors:[]}}},7481:(e,o,a)=>{"use strict";a.r(o),a.d(o,{default:()=>Q});var n=a(6252);const s=(0,n.Wm)("h1",{id:"docker-deployment"},[(0,n.Wm)("a",{class:"header-anchor",href:"#docker-deployment"},"#"),(0,n.Uk)(" Docker deployment")],-1),t=(0,n.Wm)("p",null,[(0,n.Uk)("DIVA is built with a focus on scalability, modularisation and expandability using a microservice architecture. Our team relies on the latest technologies for container-based development and deployment of the system using Docker. All system components are containerized and have current images that are continuously built in the CI pipeline. In this guide we will learn how to get DIVA running with "),(0,n.Wm)("code",null,"docker-compose"),(0,n.Uk)(".")],-1),r={class:"custom-container tip"},l=(0,n.Wm)("p",{class:"custom-container-title"},"TIP",-1),i=(0,n.Uk)("Make sure to read the "),c=(0,n.Uk)("prerequisites"),p=(0,n.Uk)(" to know what you need to get started with Docker and Docker Compose. Also note that deployment with docker is not suitable for Production. Nonetheless, it is convenient for local development environment to quickly spin up most of the components like Kafka, Gateway and other services."),d=(0,n.Uk)("All things related to docker are located in the "),m={href:"https://github.com/FraunhoferISST/diva/blob/master/docker",target:"_blank",rel:"noopener noreferrer"},h=(0,n.Wm)("code",null,"docker/",-1),u=(0,n.Uk)(" directory. Here we have prepared a script which you can use to directly boot all components, with default environment setup. If you need a quick start, just execute the following commands:"),g=(0,n.uE)('<div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token comment"># navigate to docker/ directory</span>\n<span class="token builtin class-name">cd</span> docker\n<span class="token comment"># spin up the system</span>\n./up_core.sh\n</code></pre></div><p>The script starts all core services, profiling workflow engine, DSC and the web client application. It may take some time until all components are up and running. By default, the client should be available on <code>localhost:70</code>.</p><p>If you want to learn more about the configuration options, the following chapters will show you how to manage Docker containers, images and deployment.</p><h2 id="environment-variables"><a class="header-anchor" href="#environment-variables">#</a> Environment variables</h2><p>First with the environment variables you have the possibility to propagate settings to the containers on run time. The ENV&#39;s are used to configure exposed ports, Kafka topics, database connections, credentials etc. This makes the deployment of containers more flexible and provides you a way to configure the environment without potential collisions with other software on your machines.</p><div class="custom-container warning"><p class="custom-container-title">Ports allocation</p><p>DIVA components allocate many default ports like 80, 3000 or 27017. To avoid potential conflicts on deployment, most of the allocated ports can be configured in <code>docker/.env</code> file.</p></div>',6),f=(0,n.Uk)("All available configuration possibilities are listed in the "),k={href:"https://github.com/FraunhoferISST/diva/blob/master/docker/.env.default",target:"_blank",rel:"noopener noreferrer"},b=(0,n.Wm)("code",null,"docker/.env.default",-1),v=(0,n.Uk)(" file. This ENV template is used by default to boot the system with "),y=(0,n.Wm)("code",null,"up_core.sh",-1),w=(0,n.Uk)(" script. To override default settings, create a "),W=(0,n.Wm)("code",null,".env",-1),x=(0,n.Uk)(" file in the "),T=(0,n.Wm)("code",null,"docker/",-1),S=(0,n.Uk)(" directory and copy the contents of "),_=(0,n.Wm)("code",null,".env.default",-1),U=(0,n.Uk)(" to it. There you can adjust the deployment,"),I=(0,n.Wm)("br",null,null,-1),P=(0,n.Uk)(" and e.g. change the port of the web application as follows:"),A=(0,n.uE)('<div class="language-env ext-env"><pre class="language-env"><code>WEB_CLIENT_PORT=90\n</code></pre></div><h2 id="container-and-images-management"><a class="header-anchor" href="#container-and-images-management">#</a> Container and images management</h2><p>Now we will briefly go through the lifecycle of containers and images, from configuration to deployment in the container registry. This chapter is interesting for those who want to actively participate in the development of the system or manage containers and images in a more granular way.</p><div class="custom-container warning"><p class="custom-container-title">Environment variables</p><p>Make sure to create <code>.env</code> file on your machine like described in <a href="#environment-variables">Environment variables</a></p></div><p>We will take a brief look at how to build, push, and pull images in general. Of course, this chapter only concerns the software we have created and containerized, external images like Kafka or Elasticsearch are not of interest to us. In general, you will find multiple Docker Compose files that have the following responsibilities:</p>',5),D={href:"https://github.com/FraunhoferISST/diva/blob/master/docker/docker-compose.yml",target:"_blank",rel:"noopener noreferrer"},F=(0,n.Wm)("code",null,"docker-compose.yml",-1),E=(0,n.Uk)(" - the most interesting config file as it is a heart of the DIVA"),C={href:"https://github.com/FraunhoferISST/diva/blob/master/docker/docker-compose.faas.yml",target:"_blank",rel:"noopener noreferrer"},M=(0,n.Wm)("code",null,"docker-compose.faas.yml",-1),B=(0,n.Uk)(" - FaaS services configuration useful only for local development to build and test images"),V={href:"https://github.com/FraunhoferISST/diva/blob/master/docker/docker-compose.airflow.yml",target:"_blank",rel:"noopener noreferrer"},N=(0,n.Wm)("code",null,"docker-compose.airflow.yml",-1),K=(0,n.Uk)(" - Airflow configuration"),O={href:"https://github.com/FraunhoferISST/diva/blob/master/docker/docker-compose.profiling.yml",target:"_blank",rel:"noopener noreferrer"},j=(0,n.Wm)("code",null,"docker-compose.profiling.yml",-1),q=(0,n.Uk)(" - external profiling services used in our profiling workflows"),z={href:"https://github.com/FraunhoferISST/diva/blob/master/docker/docker-compose.monitoring.yml",target:"_blank",rel:"noopener noreferrer"},L=(0,n.Wm)("code",null,"docker-compose.monitoring.yml",-1),R=(0,n.Uk)(" - several helpful monitoring and debugging tools like Kibana that are not deployed within the system core"),G={href:"https://github.com/FraunhoferISST/diva/blob/master/docker/docker-compose.dsc.yml",target:"_blank",rel:"noopener noreferrer"},H=(0,n.Wm)("code",null,"docker-compose.dsc.yml",-1),Y=(0,n.Uk)(" - DSC Service, for demonstration purpose only"),J=(0,n.uE)('<p>The folder also contains other Docker Compose configurations that have <code>.build</code> in the suffix. These can override the normal configurations to build an image locally explicitly from source. The difference with the <code>.build</code> configurations is that the services are executed in the context of the corresponding folder. Generally, the configuration can be overwritten as follows:</p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose -f docker-compose.build.yml build resource-management\n</code></pre></div><h3 id="manage-microservices"><a class="header-anchor" href="#manage-microservices">#</a> Manage microservices</h3><p>All microservices and their dependencies are defined in <code>docker-compose.yml</code>. You will work with this file the most.</p><p><strong>Pull image</strong></p><p>Simply run the command:</p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose pull <span class="token operator">&lt;</span>service_name<span class="token operator">&gt;</span>\n<span class="token comment"># for example</span>\ndocker-compose pull user-management\n</code></pre></div><p><strong>Build image</strong></p><p>To explicitly build the image from source, specify the path to the override <code>.yml</code> :</p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose f docker-compose.yml -f docker-compose.override.yml build <span class="token operator">&lt;</span>service_name<span class="token operator">&gt;</span>\n<span class="token comment"># for example</span>\ndocker-compose f docker-compose.yml -f docker-compose.override.yml build user-management\n</code></pre></div><p><strong>Push image</strong></p><p>Push image to container registry:</p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose push <span class="token operator">&lt;</span>service_name<span class="token operator">&gt;</span>\n<span class="token comment"># for example</span>\ndocker-compose push user-management\n</code></pre></div><h3 id="manage-faas"><a class="header-anchor" href="#manage-faas">#</a> Manage FaaS</h3><p>All FaaS are defined in <code>docker-compose.faas.yml</code>.</p><p><strong>Pull image</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose -f docker-compose.faas.yml pull <span class="token operator">&lt;</span>service_name<span class="token operator">&gt;</span>\n<span class="token comment"># for example</span>\ndocker-compose -f docker-compose.faas.yml pull text-keywords-extractor\n</code></pre></div><p><strong>Build image</strong></p><p>To explicitly build the image from source, specify the path to the build <code>.yml</code> :</p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose -f docker-compose.faas.yml -f docker-compose.faas.build.yml build <span class="token operator">&lt;</span>service_name<span class="token operator">&gt;</span>\n<span class="token comment"># for example</span>\ndocker-compose -f docker-compose.faas.yml -f docker-compose.faas.build.yml build text-keywords-extractor\n</code></pre></div><p><strong>Push image</strong></p><p>Push image to container registry:</p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose -f docker-compose.faas.yml push text-keywords-extractor\n<span class="token comment"># for example</span>\ndocker-compose -f docker-compose.faas.yml push text-keywords-extractor\n</code></pre></div><h3 id="manage-airflow"><a class="header-anchor" href="#manage-airflow">#</a> Manage Airflow</h3><p>We use a slightly customized image for Airflow. The definitions for Airflow are specified in<code>docker-compose.airflow.yml</code>.</p><p><strong>Pull image</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker pull ghcr.io/fraunhoferisst/diva/airflow:<span class="token operator">&lt;</span>version<span class="token operator">&gt;</span>\n</code></pre></div><p><strong>Build image</strong></p><p>To explicitly build the image from source, specify the path to the build <code>.yml</code> :</p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose -f docker-compose.airflow.build.yml build airflow\n</code></pre></div><p><strong>Push image</strong></p><p>Push image to container registry:</p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose -f docker-compose.airflow.yml push airflow\n</code></pre></div><h3 id="manage-base-images"><a class="header-anchor" href="#manage-base-images">#</a> Manage base images</h3><p>We have several images that serve as the basis for our FaaS. They are located in <code>./base-images</code>, so first change the working directory:</p><div class="language-bash ext-sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> base-images\n</code></pre></div><p><strong>Pull image</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose pull <span class="token operator">&lt;</span>service_name<span class="token operator">&gt;</span>\n<span class="token comment"># for example</span>\ndocker-compose pull base-python3\n</code></pre></div><p><strong>Build image</strong></p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose build <span class="token operator">&lt;</span>service_name<span class="token operator">&gt;</span>\n<span class="token comment"># for example</span>\ndocker-compose build base-python3\n</code></pre></div><p><strong>Push image</strong></p><p>Push image to container registry:</p><div class="language-bash ext-sh"><pre class="language-bash"><code>docker-compose push <span class="token operator">&lt;</span>service_name<span class="token operator">&gt;</span>\n<span class="token comment"># for example</span>\ndocker-compose push base-python3\n</code></pre></div>',43),Q={render:function(e,o){const a=(0,n.up)("RouterLink"),Q=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.j4)(n.HY,null,[s,t,(0,n.Wm)("div",r,[l,(0,n.Wm)("p",null,[i,(0,n.Wm)(a,{to:"/development/deployment/"},{default:(0,n.w5)((()=>[c])),_:1}),p])]),(0,n.Wm)("p",null,[d,(0,n.Wm)("a",m,[h,(0,n.Wm)(Q)]),u]),g,(0,n.Wm)("p",null,[f,(0,n.Wm)("a",k,[b,(0,n.Wm)(Q)]),v,y,w,W,x,T,S,_,U,I,P]),A,(0,n.Wm)("ul",null,[(0,n.Wm)("li",null,[(0,n.Wm)("p",null,[(0,n.Wm)("a",D,[F,(0,n.Wm)(Q)]),E])]),(0,n.Wm)("li",null,[(0,n.Wm)("p",null,[(0,n.Wm)("a",C,[M,(0,n.Wm)(Q)]),B])]),(0,n.Wm)("li",null,[(0,n.Wm)("p",null,[(0,n.Wm)("a",V,[N,(0,n.Wm)(Q)]),K])]),(0,n.Wm)("li",null,[(0,n.Wm)("p",null,[(0,n.Wm)("a",O,[j,(0,n.Wm)(Q)]),q])]),(0,n.Wm)("li",null,[(0,n.Wm)("p",null,[(0,n.Wm)("a",z,[L,(0,n.Wm)(Q)]),R])]),(0,n.Wm)("li",null,[(0,n.Wm)("p",null,[(0,n.Wm)("a",G,[H,(0,n.Wm)(Q)]),Y])])]),J],64)}}}}]);